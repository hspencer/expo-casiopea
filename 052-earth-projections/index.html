<!doctype html>
<html lang="es">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Proyecciones v2 — SVG Export</title>
    <!-- D3 + TopoJSON + Extra Projections -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-geo-projection@4"></script>
    <style>
        :root {
            --bg: #0b0c0e;
            --panel: #111318;
            --ink: #e6e8eb;
            --muted: #9aa3ad;
            --accent: #4cc9f0;
            --ok: #70e000;
            --warn: #ffd60a;
            --error: #ff4d6d;
            --stroke: #e6e8eb;
            --land: #171a20;
            --water: #0b0c0e;
            --borders: #8aa0b5;
            --graticule: #454f5e;
            --radius: 16px;
            --shadow: 0 10px 30px rgba(0, 0, 0, .25);
            --focus: 0 0 0 3px color-mix(in oklch, var(--accent) 60%, #fff 0%);
            --ring: 0 1px 0 rgba(255, 255, 255, .045) inset, 0 8px 20px rgba(0, 0, 0, .35);
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        .app {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100%
        }

        /* Top bar */
        .toolbar {
            position: sticky;
            top: 0;
            z-index: 3;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1rem;
            align-items: center;
            padding: .75rem 1rem;
            background: var(--panel);
            box-shadow: var(--ring);
        }

        .toolbar .group {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: .6rem
        }

        .toolbar label {
            color: var(--muted);
            font-weight: 600;
            letter-spacing: .02em
        }

        .toolbar select,
        .toolbar input[type="number"],
        .toolbar input[type="range"],
        .toolbar input[type="text"] {
            appearance: none;
            border: 1px solid #1e232c;
            background: #0d1117;
            color: var(--ink);
            border-radius: 12px;
            padding: .45rem .6rem;
            outline: none;
            box-shadow: none;
            min-height: 2.2rem
        }

        .toolbar input[type="range"] {
            width: 160px;
            padding: 0;
            background: transparent
        }

        .toolbar button {
            appearance: none;
            border: 1px solid #2a2f39;
            background: #12161d;
            color: var(--ink);
            border-radius: 12px;
            padding: .55rem .9rem;
            cursor: pointer;
            font-weight: 700;
            letter-spacing: .02em;
            box-shadow: var(--ring);
        }

        .toolbar button:hover {
            border-color: #3a404d;
            transform: translateY(-1px)
        }

        .toolbar button.primary {
            background: var(--accent);
            color: #001219;
            border-color: transparent
        }

        /* Canvas area */
        .stage {
            position: relative;
            height: 100%;
        }

        .wrap {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            padding: 1rem
        }

        svg.map {
            width: 100%;
            height: 100%;
            max-width: 1600px;
            aspect-ratio: 16/9;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            background: transparent
        }

        /* Legend / status */
        .status {
            position: absolute;
            left: 1rem;
            bottom: 1rem;
            padding: .4rem .6rem;
            border-radius: 10px;
            background: rgba(0, 0, 0, .45);
            backdrop-filter: blur(6px);
            color: var(--muted)
        }

        .status b {
            color: var(--ink)
        }

        /* Simple utility */
        .hide {
            display: none !important
        }

        .sep {
            width: 1px;
            height: 1.8rem;
            background: #2a2f39;
            margin: 0 .4rem
        }

        /* Light / High contrast themes applied via JS by updating CSS vars */
    </style>
</head>

<body>
    <div class="app">
        <!-- Controls -->
        <header class="toolbar" aria-label="Controls">
            <div class="group" role="group" aria-label="Projection & data">
                <label for="projection">Projection</label>
                <select id="projection">
                    <option value="EqualEarth">EqualEarth</option>
                    <option value="NaturalEarth1">NaturalEarth1</option>
                    <option value="Robinson">Robinson</option>
                    <option value="Mercator">Mercator</option>
                    <option value="Equirectangular">Equirectangular</option>
                    <option value="Orthographic">Orthographic (globe)</option>
                    <option value="Stereographic">Stereographic</option>
                    <option value="AzimuthalEqualArea">Azimuthal Equal-Area</option>
                    <option value="AzimuthalEquidistant">Azimuthal Equidistant</option>
                    <option value="ConicConformal">Conic Conformal</option>
                    <option value="ConicEqualArea">Conic Equal-Area</option>
                    <option value="ConicEquidistant">Conic Equidistant</option>
                    <option value="Albers">Albers</option>
                    <option value="AlbersUsa">Albers USA</option>
                    <option value="Mollweide">Mollweide</option>
                </select>

                <span class="sep" aria-hidden="true"></span>

                <label for="resolution">Resolution</label>
                <select id="resolution" title="World-Atlas dataset">
                    <option value="auto">Auto (try 10m→50m→110m)</option>
                    <option value="10m">10m (experimental)</option>
                    <option value="50m" selected>50m</option>
                    <option value="110m">110m</option>
                    <option value="custom">Custom URL…</option>
                </select>
                <input id="customUrl" class="hide" type="text" placeholder="Top(Geo)JSON URL" size="36" />
            </div>

            <div class="group" role="group" aria-label="Export & theme">
                <label for="theme">Theme</label>
                <select id="theme">
                    <option value="dark" selected>Dark</option>
                    <option value="light">Light</option>
                    <option value="high">High Contrast</option>
                </select>

                <span class="sep" aria-hidden="true"></span>

                <button id="resetBtn" title="Reset view">Reset</button>
                <button id="exportBtn" class="primary" title="Export SVG">Export SVG</button>
            </div>
        </header>

        <!-- Secondary controls (contextual) -->
        <section class="toolbar" style="--panel:#0e1117" aria-label="Parameters">
            <div class="group" role="group" aria-label="View">
                <label for="scale">Scale</label>
                <input id="scale" type="range" min="120" max="1200" step="1" value="360" />

                <label for="rotateLambda">λ</label>
                <input id="rotateLambda" type="range" min="-180" max="180" step="1" value="0" />
                <label for="rotatePhi">φ</label>
                <input id="rotatePhi" type="range" min="-90" max="90" step="1" value="0" />
                <label for="rotateGamma">γ</label>
                <input id="rotateGamma" type="range" min="-180" max="180" step="1" value="0" />

                <label for="clip">Clip</label>
                <input id="clip" type="range" min="0" max="180" step="1" value="0" />

                <label for="par1" class="conicOnly">φ1</label>
                <input id="par1" class="conicOnly" type="number" step="0.1" value="29.5" style="width:6ch" />
                <label for="par2" class="conicOnly">φ2</label>
                <input id="par2" class="conicOnly" type="number" step="0.1" value="45.5" style="width:6ch" />

                <label for="graticuleToggle">Graticule</label>
                <select id="graticuleToggle">
                    <option value="on" selected>On</option>
                    <option value="off">Off</option>
                </select>
                <label for="graticuleStep">Step</label>
                <input id="graticuleStep" type="number" min="1" max="30" step="1" value="10" style="width:6ch" />
            </div>
            <div class="group" role="group" aria-label="Layers">
                <label for="showCountries">Countries</label>
                <select id="showCountries">
                    <option value="fill" selected>Fill + borders</option>
                    <option value="borders">Borders only</option>
                    <option value="off">Off</option>
                </select>
                <label for="strokeWidth">Stroke</label>
                <input id="strokeWidth" type="range" min="0.25" max="2.5" step="0.05" value="0.6" />
            </div>
        </section>

        <!-- Stage -->
        <main class="stage">
            <div class="wrap">
                <svg id="map" class="map" viewBox="0 0 1280 720" role="img" aria-label="World map"></svg>
                <div class="status" id="status">Loading…</div>
            </div>
        </main>
    </div>

    <script>
        // ---------- Utilities
        const $ = (sel) => document.querySelector(sel);
        const statusEl = $('#status');
        const setStatus = (msg, tone = '') => {
            statusEl.textContent = msg; statusEl.style.border = 'none';
            if (tone === 'ok') statusEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--ok');
            else if (tone === 'warn') statusEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--warn');
            else if (tone === 'error') statusEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--error');
            else statusEl.style.color = 'var(--muted)';
        };

        // ---------- Theme handling (ensures contrast for backgrounds)
        const applyTheme = (mode) => {
            const r = document.documentElement.style;
            if (mode === 'light') {
                r.setProperty('--bg', '#f5f7fb');
                r.setProperty('--panel', '#ffffff');
                r.setProperty('--ink', '#0b0c0e');
                r.setProperty('--muted', '#5a646e');
                r.setProperty('--stroke', '#101418');
                r.setProperty('--land', '#dfe6ef');
                r.setProperty('--water', '#f5f7fb');
                r.setProperty('--borders', '#556170');
                r.setProperty('--graticule', '#c3ccd6');
            } else if (mode === 'high') {
                r.setProperty('--bg', '#000');
                r.setProperty('--panel', '#000');
                r.setProperty('--ink', '#fff');
                r.setProperty('--muted', '#ddd');
                r.setProperty('--stroke', '#fff');
                r.setProperty('--land', '#000');
                r.setProperty('--water', '#000');
                r.setProperty('--borders', '#fff');
                r.setProperty('--graticule', '#777');
            } else { // dark
                r.setProperty('--bg', '#0b0c0e');
                r.setProperty('--panel', '#111318');
                r.setProperty('--ink', '#e6e8eb');
                r.setProperty('--muted', '#9aa3ad');
                r.setProperty('--stroke', '#e6e8eb');
                r.setProperty('--land', '#171a20');
                r.setProperty('--water', '#0b0c0e');
                r.setProperty('--borders', '#8aa0b5');
                r.setProperty('--graticule', '#454f5e');
            }
            draw(); // redraw with new vars
        };

        // ---------- Data: smart fetch with graceful fallback
        const atlasBase = 'https://cdn.jsdelivr.net/npm/world-atlas@2/';
        function atlasURLsFor(res) {
            return {
                land: `${atlasBase}land-${res}.json`,
                countries: `${atlasBase}countries-${res}.json`
            };
        }

        async function tryFetch(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
            return res.json();
        }

        async function loadWorld(auto = true, requestedRes = '50m', customUrl = '') {
            // Returns {land, countries, resolution}
            const tryList = auto ? ['10m', '50m', '110m'] : [requestedRes];

            // If custom URL is provided, we attempt to read as TopoJSON/GeoJSON countries only
            if (requestedRes === 'custom' && customUrl) {
                try {
                    const data = await tryFetch(customUrl);
                    return { land: null, countries: data, resolution: 'custom' };
                } catch (err) {
                    setStatus('Custom URL failed. Falling back to auto.', 'warn');
                }
            }

            for (const res of tryList) {
                const urls = atlasURLsFor(res);
                try {
                    const [land, countries] = await Promise.all([
                        tryFetch(urls.land),
                        tryFetch(urls.countries)
                    ]);
                    return { land, countries, resolution: res };
                } catch (err) {
                    // continue to next resolution
                }
            }
            throw new Error('All dataset fetch attempts failed');
        }

        // ---------- Map setup
        const svg = d3.select('#map');
        const g = svg.append('g').attr('id', 'layers');
        const bg = svg.insert('rect', ':first-child')
            .attr('class', 'background')
            .attr('x', 0).attr('y', 0)
            .attr('width', 1280).attr('height', 720)
            .attr('fill', 'var(--water)');

        const width = 1280, height = 720;
        let projection = d3.geoEqualEarth().translate([width / 2, height / 2]).scale(360);
        let path = d3.geoPath(projection);
        const graticule = d3.geoGraticule();

        // Layers
        const layer = {
            water: g.append('g').attr('id', 'water'),
            graticule: g.append('g').attr('id', 'graticule'),
            land: g.append('g').attr('id', 'land'),
            borders: g.append('g').attr('id', 'borders')
        };

        // ---------- Projections factory
        const PROJECTIONS = {
            EqualEarth: () => d3.geoEqualEarth(),
            NaturalEarth1: () => d3.geoNaturalEarth1(),
            Robinson: () => d3.geoRobinson(),
            Mercator: () => d3.geoMercator(),
            Equirectangular: () => d3.geoEquirectangular(),
            Orthographic: () => d3.geoOrthographic(),
            Stereographic: () => d3.geoStereographic(),
            AzimuthalEqualArea: () => d3.geoAzimuthalEqualArea(),
            AzimuthalEquidistant: () => d3.geoAzimuthalEquidistant(),
            ConicConformal: () => d3.geoConicConformal(),
            ConicEqualArea: () => d3.geoConicEqualArea(),
            ConicEquidistant: () => d3.geoConicEquidistant(),
            Albers: () => d3.geoAlbers(),
            AlbersUsa: () => d3.geoAlbersUsa(),
            Mollweide: () => d3.geoMollweide(),
        };

        // ---------- State
        const state = {
            dataset: null,
            resolution: '50m',
            land: null,
            countries: null,
        };

        // ---------- Controls wiring
        const projectionSel = $('#projection');
        const resolutionSel = $('#resolution');
        const customUrlInput = $('#customUrl');
        const themeSel = $('#theme');
        const scaleInput = $('#scale');
        const rLambda = $('#rotateLambda');
        const rPhi = $('#rotatePhi');
        const rGamma = $('#rotateGamma');
        const clipInput = $('#clip');
        const par1Input = $('#par1');
        const par2Input = $('#par2');
        const gradToggle = $('#graticuleToggle');
        const gradStep = $('#graticuleStep');
        const showCountriesSel = $('#showCountries');
        const strokeWidthInput = $('#strokeWidth');

        function onResolutionChange() {
            const val = resolutionSel.value;
            customUrlInput.classList.toggle('hide', val !== 'custom');
            refreshData();
        }

        function isConic(name) {
            return /Conic|Albers/.test(name);
        }

        function isAzimuthal(name) {
            return /Azimuthal|Orthographic|Stereographic/.test(name);
        }

        function updateProjection() {
            const name = projectionSel.value;
            const factory = PROJECTIONS[name] || PROJECTIONS.EqualEarth;
            projection = factory().translate([width / 2, height / 2]).scale(+scaleInput.value);

            // Rotation and clipping
            projection.rotate([+rLambda.value, +rPhi.value, +rGamma.value]);
            const clip = +clipInput.value;
            projection.clipAngle(clip > 0 ? clip : null);

            // Conic parallels
            const conic = isConic(name);
            document.querySelectorAll('.conicOnly').forEach(el => el.classList.toggle('hide', !conic));
            if (conic && projection.parallels) {
                projection.parallels([+par1Input.value, +par2Input.value]);
            }

            path = d3.geoPath(projection);
        }

        function draw() {
            if (!state.countries && !state.land) { return; }

            // Background fill (ensures exported SVG has correct contrast/contrast-safe background)
            bg.attr('fill', getComputedStyle(document.documentElement).getPropertyValue('--water'));

            layer.graticule.selectAll('*').remove();
            if (gradToggle.value === 'on') {
                const step = Math.max(1, +gradStep.value || 10);
                const g10 = d3.geoGraticule().step([step, step]);
                layer.graticule.append('path')
                    .datum(g10())
                    .attr('d', path)
                    .attr('fill', 'none')
                    .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--graticule').trim())
                    .attr('stroke-width', 0.6);
                // outline
                layer.graticule.append('path')
                    .datum({ type: 'Sphere' })
                    .attr('d', path)
                    .attr('fill', 'none')
                    .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--graticule').trim())
                    .attr('stroke-width', 0.8);
            }

            layer.land.selectAll('*').remove();
            layer.borders.selectAll('*').remove();

            if (state.land) {
                const landFeature = topojson.feature(state.land, state.land.objects.land);
                layer.land.append('path')
                    .datum(landFeature)
                    .attr('d', path)
                    .attr('fill', getComputedStyle(document.documentElement).getPropertyValue('--land').trim())
                    .attr('stroke', 'none');
            }

            if (state.countries) {
                try {
                    let countriesFeature;
                    let bordersMesh;

                    if (state.countries.type === 'Topology') {
                        const objs = state.countries.objects || {};
                        const countriesObj =
                            objs.countries ||
                            objs.units ||
                            objs.admin ||
                            objs.ne_110m_admin_0_countries ||
                            Object.values(objs)[0];

                        if (countriesObj) {
                            countriesFeature = topojson.feature(state.countries, countriesObj);
                            bordersMesh = topojson.mesh(state.countries, countriesObj, (a, b) => a !== b);
                        }
                    } else {
                        countriesFeature = state.countries; // GeoJSON directo
                    }

                    const mode = showCountriesSel.value;
                    if (mode !== 'off') {
                        if (mode === 'fill' && countriesFeature) {
                            layer.land.selectAll('path.country')
                                .data(countriesFeature.features || [])
                                .join('path')
                                .attr('class', 'country')
                                .attr('d', path)
                                .attr('fill', getComputedStyle(document.documentElement).getPropertyValue('--land').trim())
                                .attr('stroke', 'none');
                        }
                        if (bordersMesh) {
                            layer.borders.append('path')
                                .datum(bordersMesh)
                                .attr('d', path)
                                .attr('fill', 'none')
                                .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--borders').trim())
                                .attr('stroke-width', +strokeWidthInput.value)
                                .attr('vector-effect', 'non-scaling-stroke');
                        }
                    }
                } catch (e) {
                    console.error('Countries parse error', e);
                    setStatus('No se pudieron dibujar COUNTRIES (Top(o)JSON incompatible).', 'warn');
                }
            }
            let countriesFeature;
            let bordersMesh;
            const objName = state.countries.objects ? Object.keys(state.countries.objects)[0] : null; // attempt best-guess

            if (objName) {
                countriesFeature = topojson.feature(state.countries, state.countries.objects[objName]);
                bordersMesh = topojson.mesh(state.countries, state.countries.objects[objName], (a, b) => a !== b);
            } else {
                // If already GeoJSON
                countriesFeature = state.countries;
            }

            const mode = showCountriesSel.value;
            if (mode !== 'off') {
                if (mode === 'fill' && countriesFeature) {
                    layer.land.selectAll('path.country')
                        .data(countriesFeature.features)
                        .join('path')
                        .attr('class', 'country')
                        .attr('d', path)
                        .attr('fill', getComputedStyle(document.documentElement).getPropertyValue('--land').trim())
                        .attr('stroke', 'none');
                }
                if (bordersMesh) {
                    layer.borders.append('path')
                        .datum(bordersMesh)
                        .attr('d', path)
                        .attr('fill', 'none')
                        .attr('stroke', getComputedStyle(document.documentElement).getPropertyValue('--borders').trim())
                        .attr('stroke-width', +strokeWidthInput.value)
                        .attr('vector-effect', 'non-scaling-stroke');
                }
            }
        }

        setStatus(`Projection: ${projectionSel.value} • Res: ${state.resolution} • Scale: ${scaleInput.value}`);
  }

        async function refreshData() {
            try {
                setStatus('Loading data…');
                const resSel = resolutionSel.value;
                const auto = resSel === 'auto';
                const result = await loadWorld(auto, resSel, customUrlInput.value.trim());
                state.resolution = result.resolution;
                state.land = result.land;
                state.countries = result.countries;
                setStatus(`Data loaded (${state.resolution}).`, 'ok');
                draw();
            } catch (err) {
                console.error(err);
                setStatus('Failed to load datasets.', 'error');
            }
        }

        // ---------- Export SVG (inline styles + background rect preserved)
        function exportSVG() {
            const clone = svg.node().cloneNode(true);
            // Inline important presentation attributes for portability
            const cssVars = getComputedStyle(document.documentElement);
            const strokeColor = cssVars.getPropertyValue('--borders').trim();
            const landFill = cssVars.getPropertyValue('--land').trim();
            const waterFill = cssVars.getPropertyValue('--water').trim();

            // Ensure background exists and has proper fill
            const bgRect = clone.querySelector('rect.background');
            if (bgRect) bgRect.setAttribute('fill', waterFill);

            // Countries/land
            clone.querySelectorAll('#land path').forEach(p => {
                if (!p.getAttribute('fill')) p.setAttribute('fill', landFill);
                p.setAttribute('stroke', 'none');
            });

            // Borders
            clone.querySelectorAll('#borders path').forEach(p => {
                p.setAttribute('fill', 'none');
                p.setAttribute('stroke', strokeColor);
                p.setAttribute('stroke-width', strokeWidthInput.value);
                p.setAttribute('vector-effect', 'non-scaling-stroke');
            });

            // Graticule
            clone.querySelectorAll('#graticule path').forEach(p => {
                p.setAttribute('fill', 'none');
                p.setAttribute('stroke', cssVars.getPropertyValue('--graticule').trim());
                p.setAttribute('stroke-width', 0.6);
            });

            // Serialize
            const ser = new XMLSerializer();
            const src = `<?xml version="1.0" encoding="UTF-8"?>\n` + ser.serializeToString(clone);
            const blob = new Blob([src], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `map-${projectionSel.value}-${state.resolution}.svg`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        // ---------- Event listeners
        projectionSel.addEventListener('change', () => { updateProjection(); draw(); });
        resolutionSel.addEventListener('change', onResolutionChange);
        customUrlInput.addEventListener('change', refreshData);
        themeSel.addEventListener('change', (e) => applyTheme(e.target.value));
        scaleInput.addEventListener('input', () => { updateProjection(); draw(); });
        rLambda.addEventListener('input', () => { updateProjection(); draw(); });
        rPhi.addEventListener('input', () => { updateProjection(); draw(); });
        rGamma.addEventListener('input', () => { updateProjection(); draw(); });
        clipInput.addEventListener('input', () => { updateProjection(); draw(); });
        par1Input.addEventListener('change', () => { updateProjection(); draw(); });
        par2Input.addEventListener('change', () => { updateProjection(); draw(); });
        gradToggle.addEventListener('change', draw);
        gradStep.addEventListener('change', draw);
        showCountriesSel.addEventListener('change', draw);
        strokeWidthInput.addEventListener('input', draw);
        $('#exportBtn').addEventListener('click', exportSVG);
        $('#resetBtn').addEventListener('click', () => {
            scaleInput.value = 360; rLambda.value = 0; rPhi.value = 0; rGamma.value = 0; clipInput.value = 0;
            par1Input.value = 29.5; par2Input.value = 45.5; gradStep.value = 10; gradToggle.value = 'on';
            showCountriesSel.value = 'fill'; strokeWidthInput.value = 0.6; projectionSel.value = 'EqualEarth';
            updateProjection(); draw();
        });

        // ---------- Init
        (async function init() {
            applyTheme('dark');
            updateProjection();
            await refreshData();
        })();
    </script>
</body>

</html>